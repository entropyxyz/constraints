//! This supports core traits and types for supporting new architectures and constraints, and interfacing with them.

/// Contains types, traits, and macros generated by `wit_bindgen` from the `wit/index.wit` file.
/// 
/// In the future, it would be nice to define these types in Rust, generate `.wit` files from them, instead of writing the `*.wit` files by hand.
/// One initiative towards this is the `witgen` crate, but it is outdated.
pub mod bindgen {
    wit_bindgen::generate!({
        world: "constraint",
        macro_export,
    });
}

pub use bindgen::Error;

// extern crate alloc;

// use thiserror::Error;
// use witgen::witgen;

pub mod constraints;

pub use architecture::*;
pub use constraints::*;


/// Errors related to parsing and evaulating constraints.
// TODO Should this be a String or something else
// #[witgen]
// #[derive(Error, Debug, PartialEq)]
// pub enum Error {
//     /// Transaction request could not be parsed
//     #[error("Invalid transaction request: {0}")]
//     InvalidTransactionRequest(String),
//     /// Transaction request did not meet constraint requirements.
//     #[error("Error evaluating constraints: {0}")]
//     Evaluation(String),
// }

// impl Into<

/// Each architecture should implement these.
pub mod architecture {
    use super::bindgen::Error;
    use serde::{Deserialize, Serialize};

    /// Trait for defining important types associated with an architecture.
    pub trait Architecture: Serialize + for<'de> Deserialize<'de> {
        /// Account type for that chain(SS58, H160, etc)
        type Address: Eq + Serialize + for<'de> Deserialize<'de> + From<Self::AddressRaw>;
        /// Account type as it is stored in the database
        type AddressRaw: Eq + Serialize + for<'de> Deserialize<'de> + From<Self::Address>;
        /// Transaction request type for unsigned transactions
        type TransactionRequest: GetSender<Self>
            + GetReceiver<Self>
            + Serialize
            + for<'de> Deserialize<'de>
            + Parse<Self>
            + TryParse<Self>;
    }

    /// Trait for getting the the sender of a transaction.
    pub trait GetSender<A: Architecture> {
        fn sender(&self) -> Option<A::Address>;
    }

    /// Trait for getting the the receiver of a transaction.
    pub trait GetReceiver<A: Architecture> {
        fn receiver(&self) -> Option<A::Address>;
    }

    /// DEPRECATED: Use `TryParse`
    /// 
    /// Trait for parsing a raw transaction request into its native transaction request struct.
    pub trait Parse<A: Architecture> {
        fn parse(raw_tx: String) -> Result<A::TransactionRequest, Error>;
    }

    /// Tries to parse a raw transaction request into its native transaction request struct.
    pub trait TryParse<A: Architecture> {
        fn try_parse(raw_tx: &[u8]) -> Result<A::TransactionRequest, Error>;
    }
}

pub mod runtime {
    
    

    // /// Contains signature request data that is used by the constraints runtime. Passed into `wasmtime::Store` for state (or maybe `wasmtime::Linker`).
    // #[witgen]
    // pub struct EvaluationState {
    //     /// The preimage of the user's data under constraint evaulation (eg. RLP-encoded ETH transaction request).
    //     data: Vec<u8>
    // }
}

/// Includes items that should be imported into most scopes
pub mod prelude {
    // reexport getrandom custom handler (move to macro)
    pub use getrandom::register_custom_getrandom;
    // reexport all core traits
    pub use super::architecture::*;

    use core::num::NonZeroU32;
    use getrandom::Error;

    /// Custom `getrandom()` handler that always returns an error.
    /// 
    /// `getrandom` is a commonly used package for sourcing randomness.This should return an error for now,
    /// but in the future it might make sense for the validators to determinstically source randomness from
    /// BABE (eg. at a certain block)
    /// 
    /// From https://docs.rs/getrandom/latest/getrandom/macro.register_custom_getrandom.html
    // TODO This should get throw into the macros 
    pub fn always_fail(_buf: &mut [u8]) -> Result<(), Error> {
        let code = NonZeroU32::new(Error::CUSTOM_START.saturating_add(1)).unwrap();
        Err(Error::from(code))
    }
}